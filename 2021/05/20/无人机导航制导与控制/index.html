<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="导航：无人机获得自己当前（在某个参照系下）的位置、速度等信息，必要时还需要获得当前（相对于某个参照系）的姿态、姿态角速度等信息。“知道自己在哪，知道自己的姿态”。 制导：无人机发现（或外部输入）目标的位置、速度等信息，并根据自己的位置、速度以及内部性能和外部环境的约束条件，获得抵达目标所需的位置或速度指令。 “知道目标在哪，如何抵达目标”。  按照规划的航路点飞行时，计算无人机径直或者沿某个航线">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%AF%BC%E8%88%AA%E5%88%B6%E5%AF%BC%E4%B8%8E%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="导航：无人机获得自己当前（在某个参照系下）的位置、速度等信息，必要时还需要获得当前（相对于某个参照系）的姿态、姿态角速度等信息。“知道自己在哪，知道自己的姿态”。 制导：无人机发现（或外部输入）目标的位置、速度等信息，并根据自己的位置、速度以及内部性能和外部环境的约束条件，获得抵达目标所需的位置或速度指令。 “知道目标在哪，如何抵达目标”。  按照规划的航路点飞行时，计算无人机径直或者沿某个航线">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://img.mp.itc.cn/upload/20170327/f361c2fc005443068fb6fcfb2391a989.jpeg">
<meta property="og:image" content="http://img.mp.itc.cn/upload/20170327/bb233c0cbf6842db9feee2052113b57b_th.jpeg">
<meta property="og:image" content="http://img.mp.itc.cn/upload/20170327/231ef0cd124c40829cb0e855f71af25b.jpeg">
<meta property="article:published_time" content="2021-05-19T20:41:58.688Z">
<meta property="article:modified_time" content="2021-05-18T03:49:26.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.mp.itc.cn/upload/20170327/f361c2fc005443068fb6fcfb2391a989.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-无人机导航制导与控制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%AF%BC%E8%88%AA%E5%88%B6%E5%AF%BC%E4%B8%8E%E6%8E%A7%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2021-05-19T20:41:58.688Z" itemprop="datePublished">2021-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="http://img.mp.itc.cn/upload/20170327/f361c2fc005443068fb6fcfb2391a989.jpeg" alt="导航制导与控制"></p>
<p>导航：无人机获得自己当前（在某个参照系下）的位置、速度等信息，必要时还需要获得当前（相对于某个参照系）的姿态、姿态角速度等信息。“知道自己在哪，知道自己的姿态”。</p>
<p>制导：无人机发现（或外部输入）目标的位置、速度等信息，并根据自己的位置、速度以及内部性能和外部环境的约束条件，获得抵达目标所需的位置或速度指令。 “知道目标在哪，如何抵达目标”。</p>
<ul>
<li>按照规划的航路点飞行时，计算无人机径直或者沿某个航线飞抵航路点的指令；</li>
<li>采用基于计算机视觉目标跟踪的光学制导时，根据目标在视场中的位置（以及摄像头可能存在的离轴角）计算跟踪目标所需的过载或者姿态角速度指令；</li>
<li>当预装（或 SLAM 获得的）地图中存在需要规避的障碍物或禁飞区时，根据无人机飞行性能计算可行的规避路线或者速度指令。</li>
</ul>
<p>控制：根据当前的速度、姿态等信息，通过执行机构作用来改变姿态、速度等参数，进而实现稳定飞行或跟踪制导指令。 “改变飞行姿态，跟踪制导指令”。</p>
<p>联系：</p>
<ul>
<li>在指令计算和执行上有顺承关系</li>
<li>在实际系统中，三者可能会有很多交叉因素。</li>
<li>导航系统中所测量或估计出的角速度，既要用于导航系统的速度和位置估计，又要用于姿态控制；</li>
<li>在一些高机动性的飞行器和空天飞行器上有制导与控制一体化设计的趋势。</li>
</ul>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><h2 id="基于绝对参考系"><a href="#基于绝对参考系" class="headerlink" title="基于绝对参考系"></a>基于绝对参考系</h2><h3 id="惯性导航"><a href="#惯性导航" class="headerlink" title="惯性导航"></a>惯性导航</h3><h4 id="惯性平台"><a href="#惯性平台" class="headerlink" title="惯性平台"></a>惯性平台</h4><h4 id="捷联导航"><a href="#捷联导航" class="headerlink" title="捷联导航"></a>捷联导航</h4><h2 id="基于距离测量的导航"><a href="#基于距离测量的导航" class="headerlink" title="基于距离测量的导航"></a>基于距离测量的导航</h2><h3 id="卫星导航"><a href="#卫星导航" class="headerlink" title="卫星导航"></a>卫星导航</h3><h3 id="室内定位"><a href="#室内定位" class="headerlink" title="室内定位"></a>室内定位</h3><p>WIFI 定位和 UWB 定位技术</p>
<h2 id="基于特征匹配的导航"><a href="#基于特征匹配的导航" class="headerlink" title="基于特征匹配的导航"></a>基于特征匹配的导航</h2><h3 id="地形匹配"><a href="#地形匹配" class="headerlink" title="地形匹配"></a>地形匹配</h3><h3 id="运动捕捉系统"><a href="#运动捕捉系统" class="headerlink" title="运动捕捉系统"></a>运动捕捉系统</h3><p><strong>稀疏光流算法</strong>：根据灰度图像中特征点的运动计算出无人机的运动速度</p>
<p><strong>SLAM</strong>:通过将运动中实时采集的图像特征性信息与惯导等系统信息进行融合，从而可以在未知环境中一边完成周围场景的三维模型重建，一边进行自身在场景中相对位置和速度的解算。</p>
<h1 id="制导"><a href="#制导" class="headerlink" title="制导"></a>制导</h1><h2 id="航点和航线跟踪"><a href="#航点和航线跟踪" class="headerlink" title="航点和航线跟踪"></a>航点和航线跟踪</h2><ul>
<li><p>现阶段大多数军用还是民用无人机在自动飞行过程中仅需完成航路点或航线的跟踪；</p>
</li>
<li><p>多旋翼无人机，跟踪航路点时只需要将飞行速度方向对准下一个航路点，跟踪航线也仅需首先飞到航线上距离当前位置最近的点即可；</p>
</li>
<li><p>对于固定翼无人机相对复杂。因为固定翼无人机的速度方向需要通过航向来改变，而航向则需要通过滚转来改变，这就使得滚转角与速度方向之间形成了近似二阶环节的过程，这通常可以运用导弹的比例导引法来实现航路点跟踪。</p>
</li>
</ul>
<h3 id="比例导引法"><a href="#比例导引法" class="headerlink" title="比例导引法"></a>比例导引法</h3><p>让飞行器速度矢量在空间中的转动角速度正比于飞行器与目标间的视线角变化率，对于航路点这一静止目标，只需要无人机与航路点之间的距离足够，就可以保证准确抵达下一个航路点，而对于航线跟踪，则需要选择一个虚拟的目标点使得无人机首先向航线靠近，然后再逐步将方向对准航线方向。</p>
<p><img src="http://img.mp.itc.cn/upload/20170327/bb233c0cbf6842db9feee2052113b57b_th.jpeg" alt="img"></p>
<h2 id="复杂制导"><a href="#复杂制导" class="headerlink" title="复杂制导"></a>复杂制导</h2><p>随着无人机在多种场景下应用的不断深入，除了航路点和航线的跟踪以外，无人机抵达目标的<strong>最优路径选择</strong>，<strong>障碍物或禁飞区规避</strong>以及多机<strong>协同工作</strong>所需要的制导策略越来越复杂。</p>
<h3 id="最优控制"><a href="#最优控制" class="headerlink" title="最优控制"></a>最优控制</h3><p>最优控制方法在航天器轨道转移、火箭入轨制导等问题中起到了良好的效果</p>
<h3 id="特殊路径优化方法"><a href="#特殊路径优化方法" class="headerlink" title="特殊路径优化方法"></a>特殊路径优化方法</h3><p>大气中飞行的无人机路径规划，基于间接法的最优控制问题很难求解，因此无人机路径规划往往采用<strong>基于网格地图的搜索算法</strong>，或者蚁群算法、遗传算法等特殊的路径优化方法。</p>
<ul>
<li>基于概率地图的搜索算法中，首先运用随机概率方法在自由空间（任务空间中，除去障碍物后的空间）中选取采样点，并选取距离当前点最近的 k 个点构成当前点的临近点集，然后利用局部规划器将当前点与其临近点集中的所有点用直线段连接起来，同时进行相交检验，将不与障碍物相交的直线段保留下来构成一个图，作为初始路径， 完成路径规划的学习阶段；在查询阶段，运用优化方法对上述图进行搜索，从而得到由图的边构成的从出发点到目的点并满足优化目标的路径。</li>
<li>人工势场法，其基本思想是将无人机的运动，设计成一种在抽象的人造引力场中的运动，如下图所示，目标物对无人机产生 “引力”，而障碍物对无人机产生 “斥力”，通过求解目标和所有障碍物对无人机产生的合力，就可以得到无人机运动速度或加速度指令。相对于大多数搜索算法，人工势场法运算量更小，且得到的轨迹更平滑。</li>
</ul>
<p>以上这两类制导算法通常适用于一架无人机的航路跟踪或路径规划，而当设计无人机编队甚至集群时，问题复杂程度则骤增。对于集群中的某个无人机来说，其他无人机既是可以协作和互通信息的伙伴，同时又是快速移动的障碍物，而整个集群的路径规划有需要考虑集群以及其中每一架无人机特性所形成的约束条件，或者当集群处于协同作战模式时，又需要对目标自发形成各角度的全向饱和攻击，当然，这其中需要解决的问题正是当前研究的热点。</p>
<h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>最常用的控制算法还是历久弥新的 PID，通过将被控参数参考值与当前值误差的比例、积分和微分进行适当组合，便能够完成大部分近似线性系统的有效控制。</p>
<p><img src="http://img.mp.itc.cn/upload/20170327/231ef0cd124c40829cb0e855f71af25b.jpeg" alt="img"></p>
<ul>
<li>位置型</li>
</ul>
<p>$$<br>u(k)=K_p(err(k)+\frac{T}{T_i}\sum{err(j)}+\frac{T_d}{T}(err(k)-err(k-1)))<br>$$</p>
<p>$$<br>u(k)=K_p(err(k)+K_i\sum{err(j)}+K_d(err(k)-err(k-1)))<br>$$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pid</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> setSpeed;            <span class="comment">// 定义设定值</span></span><br><span class="line">    <span class="keyword">float</span> c;        <span class="comment">// 定义实际值</span></span><br><span class="line">    <span class="keyword">float</span> err;                <span class="comment">// 定义偏差值</span></span><br><span class="line">    <span class="keyword">float</span> err_last;            <span class="comment">// 定义上一个偏差值</span></span><br><span class="line">    <span class="keyword">float</span> Kp,Ki,Kd;            <span class="comment">// 定义比例、积分、微分系数</span></span><br><span class="line">    <span class="keyword">float</span> output;          <span class="comment">// 定义电压值（控制执行器的变量）</span></span><br><span class="line">    <span class="keyword">float</span> integral;            <span class="comment">// 定义积分值</span></span><br><span class="line">    <span class="keyword">float</span> minOut;</span><br><span class="line">    <span class="keyword">float</span> maxOut;</span><br><span class="line">&#125;PID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****初始化**********/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PID_init</span><span class="params">(PID pid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;PID_init begin \n&quot;);</span></span><br><span class="line">    pid.setSpeed=<span class="number">0.0</span>;</span><br><span class="line">    pid.setSpeed=<span class="number">0.0</span>;</span><br><span class="line">    pid.err=<span class="number">0.0</span>;</span><br><span class="line">    pid.err_last=<span class="number">0.0</span>;</span><br><span class="line">    pid.voltage=<span class="number">0.0</span>;</span><br><span class="line">    pid.integral=<span class="number">0.0</span>;</span><br><span class="line">    pid.Kp=<span class="number">0.2</span>;</span><br><span class="line">    pid.Ki=<span class="number">0.015</span>;</span><br><span class="line">    pid.Kd=<span class="number">0.2</span>;</span><br><span class="line">    pid.minOut=<span class="number">-100</span>;</span><br><span class="line">    pid.maxOut=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//printf(&quot;PID_init end \n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********位置式PID控制器实现**********/</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">PID_Pos</span><span class="params">(PID pid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> P,D;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">    P=pid.Kp*pid.err;</span><br><span class="line">    pid.integral+=pid.err;<span class="comment">// 位置式 pid 是对积分的持续累加，容易造成积分饱和，是系统过调</span></span><br><span class="line">    D=pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">    pid.output=P+pid.Ki*pid.integral+D;</span><br><span class="line">    <span class="keyword">if</span>(pid.minOut&gt;pid.output)</span><br><span class="line">    &#123;</span><br><span class="line">        pid.integral=pid.minOut-P-D;</span><br><span class="line">        pid.output=pid.minOut</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid.maxOut&lt;pid.output)</span><br><span class="line">    &#123;</span><br><span class="line">        pid.integral=pid.maxOut-P-D;</span><br><span class="line">        pid.output=pid.minOut</span><br><span class="line">    &#125;</span><br><span class="line">    pid.err_last=pid.err;</span><br><span class="line">    <span class="keyword">return</span> pid.output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>增量式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********增量式PID控制器实现**********/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">pid_dlt</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> SetSpeed;            <span class="comment">// 定义设定值</span></span><br><span class="line">    <span class="keyword">float</span> ActualSpeed;        <span class="comment">// 定义实际值</span></span><br><span class="line">    <span class="keyword">float</span> err;                <span class="comment">// 定义偏差值</span></span><br><span class="line">    <span class="keyword">float</span> err_next;            <span class="comment">// 定义上一个偏差值</span></span><br><span class="line">    <span class="keyword">float</span> err_last;            <span class="comment">// 定义最上前的偏差值</span></span><br><span class="line">    <span class="keyword">float</span> Kp,Ki,Kd;            <span class="comment">// 定义比例、积分、微分系数</span></span><br><span class="line">&#125;PID_Dlt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PID_init</span><span class="params">(PID_Dlt pid)</span></span>&#123;</span><br><span class="line">    pid.SetSpeed=<span class="number">0.0</span>;</span><br><span class="line">    pid.ActualSpeed=<span class="number">0.0</span>;</span><br><span class="line">    pid.err=<span class="number">0.0</span>;</span><br><span class="line">    pid.err_last=<span class="number">0.0</span>;</span><br><span class="line">    pid.err_next=<span class="number">0.0</span>;</span><br><span class="line">    pid.Kp=<span class="number">0.2</span>;</span><br><span class="line">    pid.Ki=<span class="number">0.015</span>;</span><br><span class="line">    pid.Kd=<span class="number">0.2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">PID_Dlt</span><span class="params">(PID_Dlt pid)</span></span>&#123;</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">    <span class="keyword">float</span> incrementSpeed=pid.Kp*(pid.err-pid.err_next)+pid.Ki*pid.err+pid.Kd*(pid.err<span class="number">-2</span>*pid.err_next+pid.err_last);<span class="comment">// 只和前后三次的误差值有关，也方便计算</span></span><br><span class="line">    pid.ActualSpeed+=incrementSpeed;</span><br><span class="line">    pid.err_last=pid.err_next;</span><br><span class="line">    pid.err_next=pid.err;</span><br><span class="line">    <span class="keyword">return</span> pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="改进PID："><a href="#改进PID：" class="headerlink" title="改进PID："></a>改进PID：</h2><h3 id="增益调度"><a href="#增益调度" class="headerlink" title="增益调度"></a>增益调度</h3><p>既然 PID 控制器设计过程一般是在某个平衡点处做系统的小扰动线性化方程（平心而论，工程中还真不都是这么按流程来，各种野路子都有），进而完成设计的，那么只要在正常工作范围（对于无人机来说可以是飞行包线）内选取足够的平衡点，并根据每个平衡点的模型选择合适的 PID 控制参数，这样就可以在控制器工作中通过插值等方式选择相应平衡点附近的控制参数，这种变参数的方法就是一种增益调度方法，而基于增益调度的 PID 控制器就可以针对具有一定非线性特性的系统进行控制。这种方法在飞行控制中已应用多年。</p>
<h3 id="参数自适应"><a href="#参数自适应" class="headerlink" title="参数自适应"></a>参数自适应</h3><p>比如以系统积分误差性能指标为准则，搜索使得误差性能指标为最小的参数作为控制器参数，又或者基于神经网络和遗传算法的参数自适应等，不过这些方法在工程中使用的比较少。</p>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>通过将被控系统分为内外环，只需要内外环的固有频率有一定的差别（比如说内环频率是外环的五倍以上，无人机的姿态响应和位置响应一般可以满足），即可用实现快变量和慢变量的分别控制，通过简单的调参就可以实现快速的内环响应和精确的外环控制，并具有比单个控制器更好的抗干扰性能。</p>
<p> 内环 P：从小到大，拉动四轴越来越困难，越来越感觉到四轴在抵抗你的拉动；到比较大的数值时，四轴自己会高频震动，肉眼可见，此时拉扯它，它会快速的振荡几下，过几秒钟后稳定；继续增大，不用加人为干扰，自己发散翻机。<br>  特别注意：只有内环 P 的时候，四轴会缓慢的往一个方向下掉，这属于正常现象。这就是系统角速度静差。<br>  内环 I：前述 PID 原理可以看出，积分只是用来消除静差，因此积分项系数个人觉得没必要弄的很大，因为这样做会降低系统稳定性。从小到大，四轴会定在一个位置不动，不再往下掉；继续增加 I 的值，四轴会不稳定，拉扯一下会自己发散。</p>
<p>特别注意：增加 I 的值，四轴的定角度能力很强，拉动他比较困难，似乎像是在钉钉子一样，但是一旦有强干扰，它就会发散。这是由于积分项太大，拉动一下积分速度快，给的补偿非常大，因此很难拉动，给人一种很稳定的错觉。</p>
<p>内环 D：这里的微分项 D 为标准的 PID 原理下的微分项，即本次误差 - 上次误差。在角速度环中的微分就是角加速度，原本四轴的震动就比较强烈，引起陀螺的值变化较大，此时做微分就更容易引入噪声。因此一般在这里可以适当做一些滑动滤波或者 IIR 滤波。从小到大，飞机的性能没有多大改变，只是回中的时候更加平稳；继续增加 D 的值，可以肉眼看到四轴在平衡位置高频震动 (或者听到电机发出滋滋的声音)。前述已经说明 D 项属于辅助性项，因此如果机架的震动较大，D 项可以忽略不加。</p>
<p> 外环 P：当内环 PID 全部整定完成后，飞机已经可以稳定在某一位置而不动了。此时内环 P，从小到大，可以明显看到飞机从倾斜位置慢慢回中，用手拉扯它然后放手，它会慢速回中，达到平衡位置；继续增大 P 的值，用遥控器给不同的角度给定，可以看到飞机跟踪的速度和响应越来越快；继续增加 P 的值，飞机变得十分敏感，机动性能越来越强，有发散的趋势</p>
<h3 id="积分分离"><a href="#积分分离" class="headerlink" title="积分分离"></a>积分分离</h3><p>在启动、结束或大幅度增减设定时，短时间内系统输出有很大的偏差，会造成 PID 运算的积分积累，导致控制量超过执行机构可能允许的最大动作范围对应极限控制量，从而引起较大的超调，甚至是震荡，这是绝对不允许的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> pid.Kp=<span class="number">0.2</span>;</span><br><span class="line">    pid.Ki=<span class="number">0.04</span>;</span><br><span class="line">    pid.Kd=<span class="number">0.2</span>;  <span class="comment">// 初始化过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(pid.err)&gt;<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    index=<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    index=<span class="number">1</span>;</span><br><span class="line">    pid.integral+=pid.err;</span><br><span class="line">    &#125;</span><br><span class="line">  pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);    </span><br></pre></td></tr></table></figure>



<h3 id="积分抗饱和"><a href="#积分抗饱和" class="headerlink" title="积分抗饱和"></a>积分抗饱和</h3><p> 所谓的积分饱和现象是指如果系统存在一个方向的偏差，PID 控制器的输出由于积分作用的不断累加而加大，从而导致执行机构达到极限位置，若控制器输出 U (k) 继续增大，执行器开度不可能再增大，此时计算机输出控制量超出了正常运行范围而进入饱和区。一旦系统出现反向偏差，u (k) 逐渐从饱和区退出。进入饱和区越深则退出饱和区时间越长。在这段时间里，执行机构仍然停留在极限位置而不随偏差反向而立即做出相应的改变，这时系统就像失控一样，造成控制性能恶化，这种现象称为积分饱和现象或积分失控现象。</p>
<p>  防止积分饱和的方法之一就是抗积分饱和法，该方法的思路是在计算 u (k) 时，首先判断上一时刻的控制量 u (k-1) 是否已经超出了极限范围： 如果 u (k-1)&gt;umax，则只累加负偏差；如果 u (k-1)&lt;umin，则只累加正偏差。从而避免控制量长时间停留在饱和区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">float PID_realize(float speed)&#123;</span><br><span class="line">    int index;</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line"></span><br><span class="line">   if (pid.ActualSpeed&gt;pid.umax) </span><br><span class="line">    &#123;</span><br><span class="line">       if (abs (pid.err)&gt;200)     </span><br><span class="line">        &#123;</span><br><span class="line">            index=0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            index=1;</span><br><span class="line">            if(pid.err&lt;0)</span><br><span class="line">            &#123;// 如果超上限要嘛加负值要嘛就不加了，免得进入饱和区</span><br><span class="line">              pid.integral+=pid.err;          </span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(pid.ActualSpeed&lt;pid.umin)&#123;</span><br><span class="line">        if (abs (pid.err)&gt;200)      // 积分分离过程</span><br><span class="line">        &#123;</span><br><span class="line">            index=0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            index=1;</span><br><span class="line">            if(pid.err&gt;0)</span><br><span class="line">            &#123;// 如果超下限要嘛加正值要嘛就不加了免得进入饱和区</span><br><span class="line">            pid.integral+=pid.err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (abs (pid.err)&gt;200)                    // 积分分离过程</span><br><span class="line">        &#123;</span><br><span class="line">            index=0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            index=1;</span><br><span class="line">            pid.integral+=pid.err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pid.err_last=pid.err;</span><br><span class="line">    pid.ActualSpeed=pid.voltage*1.0;</span><br><span class="line">    return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变积分的PID算法"><a href="#变积分的PID算法" class="headerlink" title="变积分的PID算法"></a>变积分的PID算法</h3><p>系统对于积分项的要求是，系统偏差大时，积分作用应该减弱甚至是全无，而在偏差小时，则应该加强。 这里给积分系数前加上一个比例值 index：</p>
<p>  当 abs (err)&lt;180 时，index=1;</p>
<p>  当 180&lt;abs (err)&lt;200 时，index=（200-abs (err)）/20;</p>
<p>  当 abs (err)&gt;200 时，index=0;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">float PID_realize(float speed)&#123;</span><br><span class="line">    float index;</span><br><span class="line">    pid.SetSpeed=speed;</span><br><span class="line">    pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line"></span><br><span class="line">    if (abs (pid.err)&gt;200)           // 变积分过程</span><br><span class="line">    &#123;</span><br><span class="line">    index=0.0;</span><br><span class="line">    &#125;else if(abs(pid.err)&lt;180)&#123;</span><br><span class="line">    index=1.0;</span><br><span class="line">    pid.integral+=pid.err;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    index=(200-abs(pid.err))/20;</span><br><span class="line">    pid.integral+=pid.err;</span><br><span class="line">    &#125;</span><br><span class="line">    pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line"></span><br><span class="line">    pid.err_last=pid.err;</span><br><span class="line">    pid.ActualSpeed=pid.voltage*1.0;</span><br><span class="line">    return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="专家系统PID"><a href="#专家系统PID" class="headerlink" title="专家系统PID"></a>专家系统PID</h3><p>  反应系统性能的两个参数是系统误差 e 和误差变化律 ec，</p>
<p>  首先我们规定一个误差的极限值，假设为 Mmax；规定一个误差的比较大的值，假设为 Mmid；规定一个误差的较小值，假设为 Mmin；</p>
<p>   e*ec&gt;0 误差在朝向误差绝对值增大的方向变化 (可以理解成速度和加速度)</p>
<p>​       若此时 abs (e)&gt;Mmid ：误差较大 强控制 </p>
<p>​       若此时 abs (e)&lt;Mmid ：误差绝对值本身并不是很大 一般的控制作用</p>
<p>   e*ec&lt;0 误差在朝向误差绝对值减小的方向变化</p>
<p>​       若此时 e*err (k-1)&gt;0 或者 e=0 ：误差的绝对值向减小的方向变化，或者已经达到平衡状态，</p>
<p>​          此时保持控制器输出不变即可。 </p>
<p>​       若此时 e*err (k-1)&lt;0 ： 误差处于极限状态。如果误差的绝对值 &gt; min，强控制 （调节幅度比较大）。 如果此时误差绝对值较小，可以考虑实施较弱控制作用。</p>
<p>   当 abs（e）&gt;Mmax 时，说明误差的绝对值已经很大了，都应该考虑控制器的输入应按最大（或最小） 输出，以达到迅速调整误差的效果，使误差绝对值以最大的速度减小。</p>
<p>   当 abs (e)&lt;Mmin 时，说明误差绝对值很小，此时加入积分，减小静态误差。</p>
<h3 id="不完全微分"><a href="#不完全微分" class="headerlink" title="不完全微分"></a>不完全微分</h3><p>虽然被控参数一般不会出现突变，但是参考值却经常会出现突变，这使得误差的微分也会突变，为了降低这种突变造成的控制量幅值，可以采用不完全微分策略，即微分只作用于被控参数（如飞行控制中的角速度阻尼）</p>
<h3 id="PID调参"><a href="#PID调参" class="headerlink" title="PID调参"></a>PID调参</h3><p>一般原则：</p>
<ul>
<li>在输出不振荡时，增大比例增益 P；</li>
<li>在输出不振荡时，减小积分时间常数 Ti；</li>
<li>在输出不振荡时，增大微分时间常数 Td；</li>
</ul>
<p>一般步骤：</p>
<ol>
<li>确定比例增益 P ：纯比例调节。输入设定为系统允许的最大值的 60%<del>70%，由 0 逐渐加大比例增益 P，直至系统出现振荡；再反过来，从此时的比例增益 P 逐渐减小，直至系统振荡消失，记录此时的比例增益 P，设定 PID 的比例增益 P 为当前值的 60%</del>70%。</li>
<li>确定积分时间常数：设定一个较大的积分时间常数 Ti 的初值，然后逐渐减小 Ti，直至系统出现振荡，之后在反过来，逐渐加大 Ti，直至系统振荡消失。记录此时的 Ti，设定 PID 的积分时间常数 Ti 为当前值的 150%~180%。</li>
<li>确定积分时间常数 Td： Td 一般不用设定，为 0 即可。若要设定，与确定 P 和 Ti 的方法相同，取不振荡时的 30%。</li>
<li>系统空载、带载联调，再对 PID 参数进行微调，直至满足要求：理想时间两个波，前高后低 4 比1</li>
</ol>
<h2 id="反馈线性化"><a href="#反馈线性化" class="headerlink" title="反馈线性化"></a>反馈线性化</h2><p>利用数学变换的方法和微分几何学的知识，将状态和控制变量转变为线性形式，然后，利用常规的线性设计的方法进行设计，将设计的结果通过反变换，转换为原始的状态和控制形式。反馈线性化可以将存在通道间耦合的非线性系统变换为解耦的线性系统，方便外环的线性控制器设计。不过该方法应用中或多或少会存在<strong>建模误差</strong>，因此设计时要重点考虑<strong>鲁棒性</strong>的因素。</p>
<h2 id="滑模变结构"><a href="#滑模变结构" class="headerlink" title="滑模变结构"></a>滑模变结构</h2><p>这种方法不需要对被控对象进行精确建模，而是在动态过程中，根据系统当前的状态 (如偏差及其各阶导数等) 有目的地不断变化，迫使系统按照预定 “滑动模态” 的状态轨迹运动。由于滑动模态可以进行设计且与对象参数及扰动无关，这就使得滑模控制具有快速响应、对应参数变化及扰动不灵敏、无需系统在线辨识、物理实现简单等优点。但是基本的滑模变结构算法存在控制参数抖振的问题，需要再趋近率设计时进行适当的优化策略。</p>
<h2 id="反步控制"><a href="#反步控制" class="headerlink" title="反步控制"></a>反步控制</h2><p>基本思路是将复杂的系统分解成不超过系统阶数的多个子系统，然后通过反向递推为每个子系统设计部分李雅普诺夫函数和中间虚拟控制量，直至设计完成整个控制器。反步方法运用于飞控系统控制器的设计可以处理一类非线性、不确定性因素的影响，而且已经被证明具有比较好稳定性及误差的收敛性。</p>
<h2 id="自适应逆"><a href="#自适应逆" class="headerlink" title="自适应逆"></a>自适应逆</h2><p>与动态逆的思想类似，这种方法运用各种自适应逆滤波网络（如 LMS 滤波器网络、神经网络等）去拟合出被控对象的逆系统，从而将控制器与被控对象构成的前向通道变换成一一映射的线性化解耦系统，而之所以称为 “自适应”，则是这个拟合出逆系统的网络可以在线学习被控对象的特性。这种方法在仿真中可以取得比传统控制方法优越很多的效果，但是由于滤波器网络可能存在无法检出的内部缺陷，所以在某些状态组合下，可能会出现故障（包括深度神经网络在内的所有神经网络都潜在此风险）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%AF%BC%E8%88%AA%E5%88%B6%E5%AF%BC%E4%B8%8E%E6%8E%A7%E5%88%B6/" data-id="ckovxlo750009c4v316qzbft1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%BC%A0%E6%84%9F%E5%99%A8%E7%89%B9%E6%80%A7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E8%BF%90%E5%8A%A8%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%AF%BC%E8%88%AA%E5%88%B6%E5%AF%BC%E4%B8%8E%E6%8E%A7%E5%88%B6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%BC%A0%E6%84%9F%E5%99%A8%E7%89%B9%E6%80%A7/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/20/%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%AF%BC%E8%88%AA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/05/20/PX4/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>